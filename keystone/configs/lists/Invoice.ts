import { list } from "@keystone-6/core";
import { allowAll } from "@keystone-6/core/access";
import {
  text,
  relationship,
  timestamp,
  integer,
  calendarDay,
  decimal,
  select,
  checkbox,
} from "@keystone-6/core/fields";

import { isAdmin, isOwner, isUser } from "../roles";
import type { AppContext } from "../../context";
import { runOrchestrator } from "../../helpers/orchestrator";
import { augmentContext } from "../../context";
import {
  INVOICE_UPDATE_STATUS_VERIFIED,
  INVOICE_UPDATE_STATUS,
} from "../../events/invoiceUpdateStatusVerified";

export function ensureSessionData(session) {
  if (!session?.data) {
    throw new Error("Unauthenticated");
  }

  return true;
}

const statusHandlers = {
  update: async ({ inputData, context, item }) => {
    const pubsubCtx = augmentContext(context);
    await pubsubCtx.pubsub.publish(INVOICE_UPDATE_STATUS, {
      invoiceId: item.id,
    });

    if (inputData.status === "verified") {
      await pubsubCtx.pubsub.publish(INVOICE_UPDATE_STATUS_VERIFIED, {
        invoiceId: item.id,
      });
    }
  },
} satisfies Partial<Record<typeof args.operation, typeof args>>;

export const Invoice = list({
  access: {
    operation: {
      query: ({ session }) => ensureSessionData(session),
      create: ({ session }) => ensureSessionData(session),
      update: ({ session }) => ensureSessionData(session),
      delete: ({ session }) => ensureSessionData(session),
    },
    filter: {
      query: ({ session, context, listKey, operation }) => {
        //console.log(session)

        // for debugging, this essentially turns of access control
        //return true

        if (isAdmin({ session })) {
          return true;
        }

        if (isOwner({ session })) {
          return {
            owner: {
              id: {
                equals: session?.data.organization.id,
              },
            }, // TODO: add support for mutliple orgs
          };
        }

        return false;
      },
    },
  },
  fields: {
    createdAt: timestamp({
      defaultValue: { kind: "now" },
      validation: { isRequired: true },
      ui: {
        createView: {
          fieldMode: "hidden",
        },
      },
    }),

    createdBy: relationship({
      ref: "User",
      ui: {
        hideCreate: true,
      },
    }),

    owner: relationship({
      ref: "Organization",
      ui: {
        hideCreate: true,
      },
    }),

    accountingPeriod: relationship({
      ref: "AccountingPeriod",
    }),

    // Used for filteringing / grouping invoices in the UI
    type: select({
      options: [
        { label: "Unverified", value: "unverified" },
        { label: "Outgoing", value: "outgoing" },
        { label: "Incoming", value: "incoming" },
      ],
      validation: { isRequired: true },
    }),

    status: select({
      options: [
        { label: "Draft", value: "draft" }, // initial status for manual invoices
        { label: "Pending", value: "pending" }, // pending assistant processing
        { label: "Processing", value: "processing" }, // actively processed by assistant
        { label: "Awaiting verification", value: "awaiting_verification" }, // processed by assistant, needs user verification
        { label: "Verified", value: "verified" }, // verified by user (manual invoices are automatically verified unless in draft status)
        { label: "Done", value: "done" }, // complete
        { label: "Failed", value: "failed" }, // verified by user (manual invoices are automatically verified unless in draft status)
      ],
      defaultValue: "draft",
      ui: {
        displayMode: "segmented-control", // or 'select'
      },
      hooks: {
        afterOperation: async (args) => {
          await statusHandlers[args.operation]?.(args);
        },
      },
    }),

    // basic info
    label: text(),

    description: text(),

    // dates
    issue_date: calendarDay({
      label: "Issued",
    }),
    due_date: calendarDay({
      label: "Due",
    }),

    // sender info
    sender_name: text(),
    sender_address: text(),

    // recipient info
    recipient_name: text(),
    recipient_address: text(),

    // amounts & vat
    subtotal_ex_vat_amount: decimal({
      scale: 2,
      //defaultValue: "0",
    }),
    vat_amount: decimal({
      scale: 2,
      //defaultValue: "0",
    }),
    total_amount: decimal({
      scale: 2,
      //defaultValue: "0",
    }),
    vat_rate: decimal({
      scale: 2,
      //defaultValue: "0",
    }),

    isPaid: checkbox({ defaultValue: false }),

    attachment: relationship({
      ref: "Attachment",
      many: false,
    }),

    entry: relationship({
      ref: "Entry",
      many: false,
    }),

    // true if invoice is generated by the assistant
    isGenerated: checkbox({ defaultValue: false }),

    verification: relationship({
      ref: "InvoiceVerification",
      many: false,
    }),
  },
  ui: {
    label: "Invoice",
    listView: {
      initialColumns: [
        "createdAt",
        "invoiceNumber",
        "status",
        "type",
        "orchestrator",
        "date",
        "description",
        "accountingPeriod",
      ],
    },
  },
  hooks: {
    beforeOperation: {
      create: async ({ context, resolvedData }) => {
        resolvedData.createdBy = {
          connect: { id: context.session.data.id },
        };

        resolvedData.owner = {
          connect: { id: context.session.data.organization.id },
        };
      },
    },
    afterOperation: {
      create: async ({ item, context, operation, inputData }) => {
        console.log("item", item);
        console.log("inputData", inputData);
        try {
          // for new invoices, check if we need to run an assistant
          if (item.status === "pending") {
            // find orchestrators for this assistant
            const orchestrators = await context.query.Orchestrator.findMany({
              where: {
                triggerEvent: {
                  equals: "invoice:afterOperation:create",
                },
                AND: { isEnabled: { equals: true } },
              },
              query: `id name`,
            });

            console.log(
              `Found ${orchestrators.length} orchestrators for invoice ${item.id}`
            );

            // run orchestrators
            for (const orchestrator of orchestrators) {
              console.log(
                `invoice afterOperation create: running orchestrator ${orchestrator.name} for invoice ${item.id}`
              );

              console.log(orchestrator);

              await context.db.Invoice.updateOne({
                where: { id: item.id },
                data: {
                  status: "processing",
                },
              });

              await runOrchestrator({
                context,
                orchestratorId: orchestrator.id,
                contextMap: item, // initial state, place everything the first agent needs here...
              });
            }
          }

          const channelName = `ON_INVOICE:${item?.createdById}`;

          const ctx = augmentContext(context);
          await ctx.pubsub.publish(channelName, { onInvoice: { ...item } });
        } catch (e) {
          await context.db.Invoice.updateOne({
            where: { id: item.id },
            data: {
              status: "failed",
            },
          });

          console.log(e);
        }
      },
      update: async ({ item, context, operation, inputData, originalItem }) => {
        const ctx = augmentContext(context);
        await ctx.pubsub.publish(`ON_INVOICE:${item?.createdById}`, {
          onInvoice: { ...item },
        });
      },
    },
  },
});
